---
phase: 03-virtual-currency-betting
plan: 13
type: execute
wave: 1
depends_on: []
files_modified:
  - server.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Room creator is charged buy-in and has BetEscrow created on room creation"
    - "Rejoining a bet room does not create duplicate BetEscrow records"
    - "Turn timer expiry triggers auto-play without ReferenceError crash"
    - "AFK kick works in both bet and free rooms without silent errors"
    - "bet:afk-acknowledge socket event is handled by the server"
    - "Disconnect handler cleans up escrow properly based on room/game status"
  artifacts:
    - path: "server.js"
      provides: "Escrow on room:create, idempotent room:join, scoping fix, afk-acknowledge handler, disconnect escrow"
      contains: "room:create.*escrow|betEscrow|bet:afk-acknowledge"
  key_links:
    - from: "server.js room:create handler"
      to: "prisma.betEscrow.create"
      via: "escrow creation after room creation"
      pattern: "room:create.*betEscrow"
    - from: "server.js room:join handler"
      to: "prisma.betEscrow.findFirst"
      via: "idempotency check before creating escrow"
      pattern: "room:join.*findFirst.*PENDING"
    - from: "server.js autoPlay/kickPlayerAFK"
      to: "sendSystemMessage/emitBalanceUpdate"
      via: "functions must be in same scope"
      pattern: "sendSystemMessage.*roomId"
---

<objective>
Fix three server-side bugs discovered during UAT round 2: (1) room creator not charged buy-in, (2) turn timer crashes due to JavaScript scoping, (3) disconnect handler missing escrow cleanup.

Purpose: Without these fixes, bet rooms have broken economics (creator plays for free, duplicate transactions for joiners), turn timers silently crash (AFK players never kicked), and disconnecting players leave orphaned escrow records.

Output: Patched server.js with correct escrow lifecycle for all entry/exit paths and working turn timer scoping.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-virtual-currency-betting/03-08-SUMMARY.md
@.planning/phases/03-virtual-currency-betting/03-11-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix room:create escrow, room:join idempotency, and disconnect escrow cleanup</name>
  <files>server.js</files>
  <action>
  Three related escrow lifecycle fixes in server.js:

  **A) Add escrow logic to room:create handler (~line 675):**
  After the room is successfully created (line 703-706), BEFORE calling callback, add bet room escrow for the creator:
  ```javascript
  // After: const room = await Promise.race([...])
  // Before: socket.join(room.id)

  if (settings.isBetRoom) {
    // Check creator balance and create escrow
    const wallet = await getWalletWithUser(socket.data.userId)
    if (wallet.frozenAt !== null) {
      // Room already created in-memory, need to clean up
      roomManager.removeRoom(room.id)
      return callback({ success: false, error: 'Wallet is frozen' })
    }
    if (wallet.balance < settings.betAmount) {
      roomManager.removeRoom(room.id)
      return callback({ success: false, error: 'Nicht genug Guthaben fuer den Einsatz' })
    }

    await prisma.$transaction(async (tx) => {
      await tx.wallet.update({
        where: { userId: socket.data.userId },
        data: { balance: { decrement: settings.betAmount } }
      })
      await tx.transaction.create({
        data: {
          type: 'BET_PLACED',
          amount: settings.betAmount,
          userId: socket.data.userId,
          description: `Einsatz: ${room.name}`
        }
      })
      await tx.betEscrow.create({
        data: {
          roomId: room.id,
          oddsId: room.id, // Use roomId as placeholder
          userId: socket.data.userId,
          amount: settings.betAmount,
          status: 'PENDING'
        }
      })
    }, { isolationLevel: 'Serializable', maxWait: 5000, timeout: 10000 })

    emitBalanceUpdate(io, socket.data.userId, wallet.balance - settings.betAmount, -settings.betAmount, `Einsatz: ${room.name}`)
  }
  ```

  NOTE: The room:create handler is INSIDE the `app.prepare().then()` closure (line 675 is inside `io.on('connection', ...)` which is inside that closure), so `emitBalanceUpdate` IS accessible here. Check the BetEscrow model schema first to ensure the `oddsId` field exists and what it expects. If there is no `oddsId` field, omit it. Look at how room:join creates BetEscrow for the exact field structure.

  Also add a `removeRoom` method to RoomManager if it doesn't exist (simple: `this.rooms.delete(roomId)`).

  **B) Add idempotency to room:join escrow (~line 738):**
  In the room:join handler, the early return for "already in room" (line 731-734) skips escrow. This is correct for reconnection. But we need idempotency for the NEW player escrow creation too. Before the `prisma.$transaction` at line 765, add:
  ```javascript
  // Check for existing escrow (idempotency)
  const existingEscrow = await prisma.betEscrow.findFirst({
    where: {
      roomId,
      userId: socket.data.userId,
      status: { in: ['PENDING', 'LOCKED'] }
    }
  })
  if (existingEscrow) {
    // Already has active escrow, skip debit and creation
    // Fall through to normal join logic below
  } else {
    // Existing escrow logic: debit balance and create BetEscrow
    await prisma.$transaction(async (tx) => { ... })
    emitBalanceUpdate(...)
  }
  ```
  Restructure the bet room block so the escrow creation is wrapped in the `else` branch.

  **C) Fix disconnect handler to handle escrow (~line 1388):**
  The current disconnect handler calls `removeUserFromAllRooms()` which removes the player from room state but does NOT handle escrow. The room:leave handler (line 833) does handle escrow. The disconnect handler should mirror that logic.

  Replace the disconnect handler:
  ```javascript
  socket.on('disconnect', async () => {
    console.log(`Client disconnected: ${socket.data.userId}`)

    // Get rooms BEFORE removing user (need room data for escrow)
    const userRoomIds = roomManager.getUserRooms(socket.data.userId).map(r => r.id)

    for (const roomId of userRoomIds) {
      const room = roomManager.getRoom(roomId)
      if (!room) continue

      // Handle escrow for bet rooms (same logic as room:leave)
      if (room.isBetRoom) {
        const wasPlayer = room.players.some(p => p.userId === socket.data.userId)
        if (wasPlayer) {
          try {
            const escrow = await prisma.betEscrow.findFirst({
              where: { roomId, userId: socket.data.userId }
            })
            if (escrow) {
              if (escrow.status === 'PENDING') {
                // Pre-game: refund
                const wallet = await getWalletWithUser(socket.data.userId)
                await prisma.$transaction(async (tx) => {
                  await tx.wallet.update({
                    where: { userId: socket.data.userId },
                    data: { balance: { increment: escrow.amount } }
                  })
                  await tx.transaction.create({
                    data: { type: 'BET_REFUND', amount: escrow.amount, userId: socket.data.userId, description: `Einsatz zurueck: ${room.name}` }
                  })
                  await tx.betEscrow.update({
                    where: { id: escrow.id },
                    data: { status: 'RELEASED', releasedAt: new Date() }
                  })
                }, { isolationLevel: 'Serializable', maxWait: 5000, timeout: 10000 })
                emitBalanceUpdate(io, socket.data.userId, wallet.balance + escrow.amount, escrow.amount, `Einsatz zurueck: ${room.name}`)
              } else if (escrow.status === 'LOCKED') {
                // Mid-game: forfeit
                await prisma.$transaction(async (tx) => {
                  await tx.betEscrow.update({ where: { id: escrow.id }, data: { status: 'FORFEITED' } })
                  await tx.transaction.create({
                    data: { type: 'BET_FORFEIT', amount: escrow.amount, userId: socket.data.userId, description: `Einsatz verfallen: ${room.name}` }
                  })
                }, { isolationLevel: 'Serializable', maxWait: 5000, timeout: 10000 })
              }
            }
          } catch (error) {
            console.error('Disconnect escrow error:', error)
          }
        }
      }

      sendSystemMessage(room.id, io, `${socket.data.displayName} hat den Raum verlassen`)
      io.to(room.id).emit('room:player-left', { userId: socket.data.userId })
    }

    // Now remove from all rooms
    roomManager.removeUserFromAllRooms(socket.data.userId)
    io.emit('room:list-update', roomManager.getPublicRooms())
  })
  ```
  </action>
  <verify>
  1. Search server.js for `room:create` handler and confirm it contains `betEscrow.create` for bet rooms
  2. Search server.js for `room:join` handler and confirm it contains `findFirst.*PENDING.*LOCKED` idempotency check
  3. Search server.js for `disconnect` handler and confirm it contains escrow handling logic (betEscrow.findFirst)
  4. Run `npx tsc --noEmit` to check for TypeScript errors (server.js is plain JS but imported modules are TS)
  </verify>
  <done>
  - Room creator in bet room has balance debited and BetEscrow PENDING created during room:create
  - Rejoining player with existing PENDING/LOCKED escrow does NOT get charged again
  - Disconnecting from bet room pre-game refunds escrow; mid-game forfeits escrow
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix turn timer scoping and add bet:afk-acknowledge handler</name>
  <files>server.js</files>
  <action>
  Two related turn timer fixes in server.js:

  **A) Move sendSystemMessage and emitBalanceUpdate to module scope:**
  The root cause is that `autoPlay()` (line 280) and `kickPlayerAFK()` (line 446) are defined at module scope (before `app.prepare().then()`), but they call `sendSystemMessage()` (line 573) and `emitBalanceUpdate()` (line 593) which are defined INSIDE the `app.prepare().then()` closure.

  Fix: Move `sendSystemMessage` and `emitBalanceUpdate` OUT of the `app.prepare().then()` closure to module scope, right before the `startTurnTimer` function (around line 250). They only need `roomManager` (module scope) and `io` (passed as parameter), plus `randomUUID` (imported at top).

  Move these two functions from their current locations (lines 573, 593) to module scope (before line 255):
  ```javascript
  // Helper function to send system messages (module scope for timer access)
  function sendSystemMessage(roomId, io, content) {
    const room = roomManager.getRoom(roomId)
    if (!room) return
    const message = {
      id: randomUUID(),
      roomId,
      userId: 'system',
      displayName: 'System',
      content,
      isSystem: true,
      timestamp: Date.now()
    }
    room.chat.push(message)
    if (room.chat.length > 100) room.chat.shift()
    io.to(roomId).emit('chat:message', message)
  }

  // Helper function to emit balance updates (module scope for timer access)
  function emitBalanceUpdate(io, userId, newBalance, change, description) {
    io.to(`user:${userId}`).emit('balance:updated', {
      newBalance,
      change,
      description
    })
  }
  ```

  Remove the duplicate definitions inside `app.prepare().then()`. All call sites already pass `io` as parameter, so no signature changes needed.

  **B) Add error handling to setTimeout in startTurnTimer:**
  Wrap the `autoPlay` call inside setTimeout with try/catch:
  ```javascript
  const timeout = setTimeout(async () => {
    try {
      await autoPlay(roomId, io)
    } catch (error) {
      console.error('Turn timer auto-play error:', error)
    }
  }, room.gameState.turnDuration * 1000)
  ```

  **C) Add bet:afk-acknowledge socket handler:**
  Inside `io.on('connection', ...)`, add a new handler for `bet:afk-acknowledge`:
  ```javascript
  socket.on('bet:afk-acknowledge', ({ roomId }) => {
    const room = roomManager.getRoom(roomId)
    if (!room) return

    const warningKey = `${roomId}:${socket.data.userId}`
    const existingWarning = afkWarnings.get(warningKey)

    if (existingWarning) {
      clearTimeout(existingWarning)
      afkWarnings.delete(warningKey)

      // Reset consecutive inactive count
      const player = room.gameState?.players.find(p => p.userId === socket.data.userId)
      if (player) {
        player.consecutiveInactive = 0
      }

      // Notify client warning is canceled
      io.to(`user:${socket.data.userId}`).emit('bet:afk-warning-cancel', { roomId })

      sendSystemMessage(roomId, io, `${socket.data.displayName} ist wieder da`)
    }
  })
  ```
  Place this handler near the other bet/game handlers (after the rematch-vote handler, around line 1385).
  </action>
  <verify>
  1. Confirm `sendSystemMessage` and `emitBalanceUpdate` are defined at module scope (before `app.prepare().then()`)
  2. Confirm NO duplicate definitions exist inside the closure
  3. Search for `bet:afk-acknowledge` handler exists in server.js
  4. Confirm `startTurnTimer` setTimeout has try/catch around autoPlay
  5. Start the server with `node server.js` and confirm no immediate errors (Ctrl+C after startup message)
  </verify>
  <done>
  - autoPlay and kickPlayerAFK can call sendSystemMessage without ReferenceError
  - Turn timer errors are caught and logged instead of crashing silently
  - bet:afk-acknowledge event resets AFK warning and consecutive inactive counter
  </done>
</task>

</tasks>

<verification>
1. `grep -n "sendSystemMessage" server.js` shows function defined at module scope AND called from autoPlay, kickPlayerAFK, and socket handlers
2. `grep -n "emitBalanceUpdate" server.js` shows function defined at module scope
3. `grep -n "betEscrow" server.js` shows escrow creation in room:create handler
4. `grep -n "afk-acknowledge" server.js` shows the new handler
5. `grep -c "function sendSystemMessage" server.js` returns exactly 1 (no duplicate)
6. Server starts without errors
</verification>

<success_criteria>
- Room creator in bet rooms is charged buy-in with BetEscrow record created
- Rejoining a room with existing escrow does not create duplicates
- Turn timer expiry correctly triggers auto-play (no silent ReferenceError)
- bet:afk-acknowledge cancels AFK warning and resets inactive counter
- Disconnect from bet room handles escrow cleanup (refund or forfeit based on status)
- Server starts and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-virtual-currency-betting/03-13-SUMMARY.md`
</output>
