---
phase: 03-virtual-currency-betting
plan: 11
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/wallet/transactions.ts
  - src/lib/actions/wallet.ts
  - server.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Transfer credits recipient even if they have never accessed their wallet"
    - "Sender is not debited if recipient credit fails"
    - "Room creation works for both free and bet rooms"
    - "Free room creation does not depend on SystemSettings"
  artifacts:
    - path: "src/lib/wallet/transactions.ts"
      provides: "creditBalance with wallet upsert"
      contains: "upsert"
    - path: "src/lib/actions/wallet.ts"
      provides: "Atomic transfer using single transaction"
    - path: "server.js"
      provides: "Robust room creation for free and bet rooms"
  key_links:
    - from: "src/lib/actions/wallet.ts"
      to: "src/lib/wallet/transactions.ts"
      via: "transferFunds calls creditBalance"
      pattern: "creditBalance"
    - from: "server.js"
      to: "prisma.systemSettings"
      via: "createRoom fetches payout ratios"
      pattern: "systemSettings"
---

<objective>
Fix two BLOCKER bugs discovered during UAT: (1) P2P transfers fail when recipient wallet doesn't exist, debiting sender without crediting recipient; (2) room creation hangs for both free and bet rooms.

Purpose: Unblock 11 skipped UAT tests that depend on transfers and room creation working.
Output: Working transfer and room creation flows.
</objective>

<execution_context>
@/home/maxi/.claude/get-shit-done/workflows/execute-plan.md
@/home/maxi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/wallet/transactions.ts
@src/lib/actions/wallet.ts
@server.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix creditBalance to handle missing wallets and make transfers atomic</name>
  <files>src/lib/wallet/transactions.ts, src/lib/actions/wallet.ts</files>
  <action>
Two bugs to fix:

**Bug A: creditBalance() assumes wallet exists (transactions.ts line 144)**

In `creditBalance()`, replace `tx.wallet.update({ where: { userId } ... })` with `tx.wallet.upsert()`. The upsert should:
- `where: { userId }`
- `update: { balance: { increment: amount } }`
- `create: { userId, balance: amount }` (wallet created with credited amount as starting balance; lazy init normally gives starting balance, but for a credit operation the initial balance IS the credited amount -- the INITIAL transaction is separate)

IMPORTANT: Also create an INITIAL transaction record when the wallet is created via upsert. To detect if it was a create vs update, query the wallet first with `findUnique`. If no wallet exists:
1. First, fetch starting balance from SystemSettings (call `getSystemSettings()` inside the transaction -- but since `creditBalance` uses its own `prisma.$transaction`, import and call it before the transaction, or better: fetch settings inside the transaction using `tx.systemSettings.findFirst()`)
2. Create the wallet with `startingBalance + amount`
3. Create an INITIAL transaction for `startingBalance`
4. Create the actual credit transaction for `amount`

Actually, the simplest correct fix: Before the `tx.wallet.update()`, check if wallet exists. If not, call the lazy init logic (similar to `getWalletWithUser` but inside the transaction context `tx`). Then proceed with the update.

Simplest approach that matches existing patterns:
```typescript
// Inside the $transaction callback, before the update:
const existingWallet = await tx.wallet.findUnique({ where: { userId } })

if (!existingWallet) {
  // Lazy init: create wallet with starting balance
  const settings = await tx.systemSettings.findFirst()
  const startingBalance = settings?.startingBalance ?? 1000

  await tx.wallet.create({
    data: {
      userId,
      balance: startingBalance,
    },
  })

  // Create INITIAL transaction
  await tx.transaction.create({
    data: {
      type: TransactionType.INITIAL,
      amount: startingBalance,
      userId,
      description: 'Initial balance',
    },
  })
}

// Now the wallet exists, proceed with the existing update + increment
const wallet = await tx.wallet.update({
  where: { userId },
  data: { balance: { increment: amount } },
})
```

Import `TransactionType` is already imported at the top of transactions.ts.

**Bug B: transferFunds() wraps two independent transactions in a fake outer transaction (wallet.ts lines 175-191)**

The current code does:
```typescript
await prisma.$transaction(async (tx) => {
  await debitBalance(...)   // starts its OWN prisma.$transaction
  await creditBalance(...)  // starts its OWN prisma.$transaction
})
```

This is NOT atomic. `debitBalance` and `creditBalance` each use the global `prisma` client to start separate transactions -- they ignore the `tx` parameter from the outer transaction. If `creditBalance` fails, `debitBalance` has already committed.

Fix: Replace the outer `prisma.$transaction` wrapper with a single atomic transaction that does both operations inline. Do NOT call the separate `debitBalance`/`creditBalance` functions (they create their own transactions). Instead, inline the logic:

```typescript
// Replace lines 175-191 with:
const result = await prisma.$transaction(async (tx) => {
  // 1. Check sender wallet exists and is not frozen
  const senderWallet = await tx.wallet.findUnique({ where: { userId: session.userId } })
  if (!senderWallet) throw new Error('Wallet nicht gefunden')
  if (senderWallet.frozenAt) throw new Error('Dein Wallet ist gesperrt')
  if (senderWallet.balance < amount) {
    throw new Error(`Nicht genug Guthaben. Verfuegbar: ${senderWallet.balance}`)
  }

  // 2. Debit sender
  await tx.wallet.update({
    where: { userId: session.userId },
    data: { balance: { decrement: amount } },
  })

  await tx.transaction.create({
    data: {
      type: TransactionType.TRANSFER_SENT,
      amount,
      userId: session.userId,
      relatedUserId: toUserId,
      description: `Transfer an ${recipient.displayName}`,
    },
  })

  // 3. Ensure recipient wallet exists (lazy init)
  let recipientWallet = await tx.wallet.findUnique({ where: { userId: toUserId } })
  if (!recipientWallet) {
    const settings = await tx.systemSettings.findFirst()
    const startingBalance = settings?.startingBalance ?? 1000
    recipientWallet = await tx.wallet.create({
      data: { userId: toUserId, balance: startingBalance },
    })
    await tx.transaction.create({
      data: {
        type: TransactionType.INITIAL,
        amount: startingBalance,
        userId: toUserId,
        description: 'Initial balance',
      },
    })
  }

  // 4. Credit recipient
  await tx.wallet.update({
    where: { userId: toUserId },
    data: { balance: { increment: amount } },
  })

  await tx.transaction.create({
    data: {
      type: TransactionType.TRANSFER_RECEIVED,
      amount,
      userId: toUserId,
      relatedUserId: session.userId,
      description: `Transfer von ${session.displayName}`,
    },
  })
}, {
  isolationLevel: Prisma.TransactionIsolationLevel.Serializable,
  maxWait: 5000,
  timeout: 10000,
})
```

Also remove the now-redundant frozen wallet check earlier in the function (around line 155-161) since it's handled inside the transaction. The daily limit check (lines 130-152) should remain OUTSIDE the transaction since it's a read-only check.

Remove the unused `senderWallet` variable and its query from outside the transaction (lines 155-161). Keep the daily limit aggregate query as-is.

Note: `Prisma` is already imported at the top of wallet.ts via the `prisma` import, but you need to add `import { Prisma } from '@prisma/client'` if not already present. Check the existing imports.

Also keep the `creditBalance` function fix in transactions.ts for other callers (server.js payout code also calls wallet.update directly, but it has the same potential issue -- however those users are always active game players who will have wallets, so the risk is low; still good to have the defensive fix in creditBalance).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no TypeScript errors in modified files. Grep for the old pattern `await debitBalance` inside `transferFunds` to confirm it's been replaced. Grep for `tx.wallet.update` in `creditBalance` to confirm the lazy init guard exists before it.
  </verify>
  <done>
Transfer is atomic: sender debit and recipient credit happen in a single Prisma transaction. If recipient has no wallet, one is created with starting balance before crediting. If any step fails, the entire transaction rolls back -- sender is never debited without recipient being credited.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix room creation hanging for free and bet rooms</name>
  <files>server.js</files>
  <action>
The `RoomManager.createRoom()` method (line 40) is async because it fetches SystemSettings for payout ratios. Two issues:

**Issue 1: Prisma Client may need regeneration**

Run `npx prisma generate` as the first step. This was already done during planning (confirmed working), but the executor should run it to ensure the server picks up the generated client.

**Issue 2: Free rooms should NOT hit the async path**

In `createRoom()` (lines 44-61), the `if (!payoutRatios && settings.isBetRoom)` guard correctly skips the Prisma query for free rooms. However, if ANY error is thrown (even in the try block for bet rooms), it could cause the room creation to fail silently.

Investigate the actual issue by adding defensive error handling. The likely root cause for free rooms hanging is that `createRoom` is async but the return value may not be awaited properly -- but looking at line 697, `await roomManager.createRoom(...)` IS used.

The real fix: The `room:create` handler at line 674 has a try/catch, but if `createRoom` throws an error that's not caught properly (e.g., if `prisma` isn't properly initialized when server.js loads), the callback may never fire.

Add these defensive changes to `server.js`:

1. In `createRoom()`, wrap the entire SystemSettings fetch in a more defensive try/catch that always falls back silently for free rooms:

```javascript
async createRoom(hostId, hostName, settings) {
  const roomId = randomUUID()

  // Only fetch payout ratios for bet rooms
  let payoutRatios = settings.payoutRatios || null
  if (!payoutRatios && settings.isBetRoom) {
    try {
      const systemSettings = await prisma.systemSettings.findFirst()
      if (systemSettings?.defaultPayoutRatios) {
        payoutRatios = systemSettings.defaultPayoutRatios
      }
    } catch (error) {
      console.error('Failed to fetch payout ratios from SystemSettings:', error.message)
    }
    // Fallback if fetch failed or no settings exist
    if (!payoutRatios) {
      payoutRatios = [
        { position: 1, percentage: 60 },
        { position: 2, percentage: 30 },
        { position: 3, percentage: 10 }
      ]
    }
  }

  const room = {
    // ... rest stays the same
  }
  // ... rest stays the same
}
```

2. In the `room:create` handler (lines 674-714), add a timeout safety net. If `createRoom` takes more than 5 seconds, return an error rather than hanging forever:

```javascript
socket.on('room:create', async (settings, callback) => {
  try {
    if (!settings || !settings.name) {
      return callback({ success: false, error: 'Invalid room settings' })
    }

    // ... existing validation ...

    // Add timeout protection
    const timeoutPromise = new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Room creation timed out')), 5000)
    )

    const room = await Promise.race([
      roomManager.createRoom(socket.data.userId, socket.data.displayName, settings),
      timeoutPromise
    ])

    socket.join(room.id)
    callback({
      success: true,
      roomId: room.id,
      room: roomManager.getPublicRooms().find(r => r.id === room.id)
    })
    io.emit('room:list-update', roomManager.getPublicRooms())
  } catch (error) {
    console.error('room:create error:', error.message)
    callback({ success: false, error: error.message })
  }
})
```

3. Also add `console.log` at the start of `createRoom` and after the room is created to make debugging easier:

```javascript
async createRoom(hostId, hostName, settings) {
  console.log('Creating room:', { hostId, isBetRoom: settings.isBetRoom, betAmount: settings.betAmount })
  // ... existing logic ...
  console.log('Room created:', roomId)
  return room
}
```

4. For free rooms specifically, ensure payoutRatios defaults to an empty array (not undefined/null) to prevent downstream issues:
```javascript
payoutRatios: payoutRatios || [],
```
This is already the case on line 79, so just verify it stays.
  </action>
  <verify>
Start the dev server with `npm run dev` and check the terminal for startup errors. Test room creation by checking if `console.log('Creating room:...')` appears in server logs. No TypeScript compilation needed for server.js (plain JS), but verify no syntax errors by running `node --check server.js`.
  </verify>
  <done>
Room creation works reliably for both free and bet rooms. Free rooms skip the SystemSettings query entirely. Bet rooms have defensive fallback if SystemSettings unavailable. A 5-second timeout prevents infinite hanging.
  </done>
</task>

</tasks>

<verification>
1. Transfer test: User A sends chips to User B (who has never visited /wallet). Both balances update correctly. User A's balance is not reduced if the transfer fails.
2. Room creation test: Create a free room -- loads instantly, no hanging. Create a bet room -- loads with bet settings applied.
3. No regressions: Daily claims, admin adjustments, and other wallet operations still work.
</verification>

<success_criteria>
P2P transfers work atomically even when recipient has no wallet. Room creation completes within seconds for both free and bet rooms. 11 previously-skipped UAT tests are unblocked.
</success_criteria>

<output>
After completion, create `.planning/phases/03-virtual-currency-betting/03-11-SUMMARY.md`
</output>
