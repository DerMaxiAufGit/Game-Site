---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/app/(auth)/layout.tsx
  - src/app/(auth)/setup/page.tsx
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/register/page.tsx
  - src/lib/actions/auth.ts
  - src/lib/validations/auth.ts
autonomous: true

must_haves:
  truths:
    - "First visitor sees setup form and can create admin account"
    - "Returning user can log in with email and password"
    - "Invited user can register via invite token link"
    - "Invalid credentials show German error toast"
    - "Setup page redirects to login if admin already exists"
    - "Login page redirects to app if already authenticated"
  artifacts:
    - path: "src/app/(auth)/setup/page.tsx"
      provides: "Admin setup form for first visitor"
      contains: "setup"
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Login form with email/password"
      contains: "login"
    - path: "src/app/(auth)/register/page.tsx"
      provides: "Registration form for invited users"
      contains: "register"
    - path: "src/lib/actions/auth.ts"
      provides: "Server actions for setup, login, register"
      contains: "setupAdmin"
    - path: "src/lib/validations/auth.ts"
      provides: "Zod schemas for all auth forms"
      contains: "loginSchema"
  key_links:
    - from: "src/app/(auth)/setup/page.tsx"
      to: "src/lib/actions/auth.ts"
      via: "useActionState with setupAdmin action"
      pattern: "useActionState.*setupAdmin"
    - from: "src/app/(auth)/login/page.tsx"
      to: "src/lib/actions/auth.ts"
      via: "useActionState with login action"
      pattern: "useActionState.*login"
    - from: "src/lib/actions/auth.ts"
      to: "src/lib/auth/session.ts"
      via: "createSession after successful auth"
      pattern: "createSession"
    - from: "src/lib/actions/auth.ts"
      to: "src/lib/db/index.ts"
      via: "prisma queries for user lookup/creation"
      pattern: "prisma\\.user\\.(create|findUnique)"
    - from: "src/app/(auth)/register/page.tsx"
      to: "src/lib/actions/auth.ts"
      via: "useActionState with registerWithInvite action"
      pattern: "useActionState.*register"
---

<objective>
Build all authentication pages: admin setup (/setup), user login (/login), and invite-based registration (/register?token=xxx). Each page uses React Server Actions with proper validation, German labels, toast error feedback, and the dark+green themed UI.

Purpose: These are the entry points for every user. Without working auth pages, no one can access the application.
Output: Three functional auth pages with server actions that create sessions and persist users to the database.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth validation schemas and server actions</name>
  <files>
    src/lib/validations/auth.ts
    src/lib/actions/auth.ts
  </files>
  <action>
    1. Create src/lib/validations/auth.ts with Zod schemas:
       - setupSchema: { username: string (3-30 chars, alphanumeric + underscore), email: string (valid email), password: string (min 8 chars), displayName: string (2-50 chars) }
       - loginSchema: { email: string (valid email), password: string (min 1 char — don't leak length requirements) }
       - registerSchema: { token: string (required), username: string (3-30 chars), password: string (min 8 chars), displayName: string (2-50 chars) }
       - Export TypeScript types inferred from each schema

    2. Create src/lib/actions/auth.ts with 'use server' directive:

       a. setupAdmin(prevState, formData):
          - Parse formData with setupSchema
          - If validation fails, return { errors: fieldErrors }
          - Check if any user exists in database (db.user.count())
          - If users exist, return { error: 'setupAlreadyDone' } (use translation key)
          - Hash password with bcrypt (10 rounds)
          - Create user with role: 'ADMIN' in a try/catch (handle P2002 unique constraint for race condition — PITFALL 2 from research)
          - Call createSession(user.id, 'ADMIN')
          - redirect('/')

       b. login(prevState, formData):
          - Parse formData with loginSchema
          - If validation fails, return { errors: fieldErrors }
          - Find user by email
          - If no user OR bcrypt.compare fails, return { error: 'invalidCredentials' }
          - If user.bannedAt is set, return { error: 'accountBanned' }
          - Call createSession(user.id, user.role)
          - redirect('/')

       c. registerWithInvite(prevState, formData):
          - Parse formData with registerSchema
          - If validation fails, return { errors: fieldErrors }
          - Find invite by token where usedAt is null and expiresAt > now
          - If no valid invite, return appropriate error ('inviteNotFound', 'inviteExpired', 'inviteUsed')
          - Hash password with bcrypt (10 rounds)
          - Use db.$transaction to atomically: create user (email from invite, role USER) AND update invite (set usedAt) — PITFALL 3 from research
          - Call createSession(user.id, 'USER')
          - redirect('/')

       d. logout():
          - Call deleteSession()
          - redirect('/login')

    CRITICAL: Use bcrypt async methods (never sync). Handle Prisma unique constraint errors (P2002) for both username and email. Return translation keys (not raw strings) in error responses so the client can use t().
  </action>
  <verify>
    1. `npm run build` passes — server actions compile correctly
    2. TypeScript: no type errors in actions or validation files
    3. All four actions exported: setupAdmin, login, registerWithInvite, logout
    4. All three schemas exported: setupSchema, loginSchema, registerSchema
  </verify>
  <done>
    - Zod validation schemas defined for all auth forms
    - setupAdmin action creates first admin user with race condition protection
    - login action authenticates with bcrypt, checks banned status, creates session
    - registerWithInvite action validates invite token, creates user atomically
    - logout action clears session and redirects
  </done>
</task>

<task type="auto">
  <name>Task 2: Build auth page components (setup, login, register)</name>
  <files>
    src/app/(auth)/layout.tsx
    src/app/(auth)/setup/page.tsx
    src/app/(auth)/login/page.tsx
    src/app/(auth)/register/page.tsx
  </files>
  <action>
    1. Create src/app/(auth)/layout.tsx:
       - Centered layout for auth pages — card in the middle of the screen
       - Dark background with subtle pattern or gradient
       - "Kniff" branding/logo at top (text-based is fine, styled with the green accent)
       - German language wrapper (NextIntlClientProvider if needed for client components)
       - Responsive: card takes full width on mobile, max-w-md on desktop

    2. Create src/app/(auth)/setup/page.tsx:
       - Server component that first checks: are there any users? If yes, redirect to /login
       - If no users exist, render SetupForm client component
       - SetupForm uses useActionState with setupAdmin action
       - Fields: username, email, password, displayName
       - Use shadcn/ui Input, Label, Button, Card components
       - All labels in German via useTranslations('auth')
       - Show pending state on submit button ("Einrichtung..." while pending)
       - Display field-level errors from server action
       - Display general errors via toast (sonner)
       - Title: "Willkommen bei Kniff" / Subtitle: "Erstelle deinen Admin-Account um loszulegen."

    3. Create src/app/(auth)/login/page.tsx:
       - Client component with useActionState and login action
       - Fields: email, password
       - shadcn/ui styled form with Card wrapper
       - German labels, pending state, error handling via toast
       - Title: "Anmelden" / Subtitle: "Melde dich mit deinen Zugangsdaten an."
       - No "register" link (invite-only system — users get direct links)

    4. Create src/app/(auth)/register/page.tsx:
       - Reads ?token= from URL search params
       - If no token, show error message ("Einladung nicht gefunden")
       - Server-side: validate token exists and is not expired/used. If invalid, show appropriate error
       - If valid token: render RegisterForm with pre-filled email (from invite, read-only)
       - Fields: email (read-only, from invite), username, password, displayName
       - Uses useActionState with registerWithInvite action
       - Hidden input for token value
       - German labels, pending state, field errors, toast for general errors
       - Title: "Registrieren" / Subtitle: "Erstelle deinen Account über die Einladung."

    STYLE NOTES:
    - All forms use the green accent for primary buttons
    - Input fields styled for dark mode (dark backgrounds, lighter borders on focus)
    - Consistent spacing and typography across all three pages
    - Toast notifications for server errors (sonner)
    - Loading/pending states use disabled button + spinner or text change
    - Password fields should have type="password"

    USE useActionState (React 19) — NOT useFormState (deprecated).
  </action>
  <verify>
    1. `npm run build` passes without errors
    2. Visit /setup — form renders with all fields and German labels
    3. Visit /login — form renders with email and password fields
    4. Visit /register?token=test — shows error for invalid token (or form if token exists)
    5. All pages are responsive (check mobile viewport)
  </verify>
  <done>
    - Auth layout renders centered card on dark background with Kniff branding
    - /setup page shows admin setup form (or redirects if admin exists)
    - /login page shows login form with email/password
    - /register page validates invite token and shows registration form
    - All forms use German labels, show loading states, and handle errors via toast
    - Forms submit to server actions and create sessions on success
  </done>
</task>

</tasks>

<verification>
1. Full auth flow works: visit /setup -> create admin -> get redirected to app
2. Login flow works: visit /login -> enter credentials -> get redirected to app
3. Register flow works: visit /register?token=VALID_TOKEN -> fill form -> get redirected to app
4. Invalid credentials show German error toast
5. Already-setup /setup redirects to /login
6. Already-logged-in user on /login gets redirected to /
7. Expired/used invite token shows appropriate German error
8. All pages render correctly on mobile viewport
</verification>

<success_criteria>
- Admin can create account via /setup (first visit only)
- Users can log in via /login with email/password
- Invited users can register via /register?token=xxx
- All error messages display in German
- Session cookies are set correctly after successful auth
- Forms are responsive and styled with dark theme + green accent
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
